<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python RecursiveCharacterTextSplitter 源码解读</title>
    <url>/2025/01/30/2025-01-30-python-recursive-character-text-splitter/</url>
    <content><![CDATA[<h1 id="python-recursivecharactertextsplitter-源码解读"><a class="markdownIt-Anchor" href="#python-recursivecharactertextsplitter-源码解读"></a> Python RecursiveCharacterTextSplitter 源码解读</h1>
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p><code>RecursiveCharacterTextSplitter</code> 是 LangChain Python 中<strong>推荐的通用文本分割器</strong>。它按<strong>分隔符优先级</strong>递归切分文本，尽量保持段落、句子、词语的完整性，直到每个块满足 <code>chunk_size</code> 限制。</p>
<ul>
<li>官方 API：<a href="https://python.langchain.com/api_reference/text_splitters/character/langchain_text_splitters.character.RecursiveCharacterTextSplitter.html">RecursiveCharacterTextSplitter</a></li>
</ul>
<h2 id="默认分隔符顺序"><a class="markdownIt-Anchor" href="#默认分隔符顺序"></a> 默认分隔符顺序</h2>
<p>按优先级依次尝试，直到切出的块不超过 <code>chunk_size</code>：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>分隔符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>"\n\n"</code></td>
<td>段落</td>
</tr>
<tr>
<td>2</td>
<td><code>"\n"</code></td>
<td>行</td>
</tr>
<tr>
<td>3</td>
<td><code>" "</code></td>
<td>空格（词）</td>
</tr>
<tr>
<td>4</td>
<td><code>""</code></td>
<td>字符（兜底）</td>
</tr>
</tbody>
</table>
<p>即：先按段落切，超长再按行，再按空格，最后才按字符切。</p>
<h2 id="核心参数"><a class="markdownIt-Anchor" href="#核心参数"></a> 核心参数</h2>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
<th>来源</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>chunk_size</code></td>
<td>int</td>
<td>1000</td>
<td>每个块的目标长度（字符数或 token 数）</td>
<td><strong>继承 TextSplitter</strong></td>
</tr>
<tr>
<td><code>chunk_overlap</code></td>
<td>int</td>
<td>200</td>
<td>相邻块之间的重叠长度</td>
<td><strong>继承 TextSplitter</strong></td>
</tr>
<tr>
<td><code>length_function</code></td>
<td>Callable</td>
<td><code>len</code></td>
<td>计算长度的方式（字符数或 token 数）</td>
<td><strong>继承 TextSplitter</strong></td>
</tr>
<tr>
<td><code>separators</code></td>
<td>List[str]</td>
<td><code>["\n\n", "\n", " ", ""]</code></td>
<td>分隔符列表，按顺序使用</td>
<td>本类 / CharacterTextSplitter</td>
</tr>
<tr>
<td><code>keep_separator</code></td>
<td>bool</td>
<td>True</td>
<td>是否在切分后的文本中保留分隔符</td>
<td>本类 / CharacterTextSplitter</td>
</tr>
<tr>
<td><code>is_separator_regex</code></td>
<td>bool</td>
<td>False</td>
<td>分隔符是否按正则解析</td>
<td>本类 / CharacterTextSplitter</td>
</tr>
</tbody>
</table>
<p><strong>继承自 TextSplitter 的参数</strong>：<code>chunk_size</code>、<code>chunk_overlap</code>、<code>length_function</code>（基类定义块大小、重叠与长度计算方式；本类在此基础上增加 <code>separators</code>、<code>keep_separator</code>、<code>is_separator_regex</code> 等与分隔符相关的配置）。</p>
<h2 id="源码解读"><a class="markdownIt-Anchor" href="#源码解读"></a> 源码解读</h2>
<p>LangChain Python 的 <code>RecursiveCharacterTextSplitter</code> 继承自 <code>TextSplitter</code>，核心逻辑在<strong>递归按分隔符切分</strong>和<strong>带重叠的合并</strong>两处。</p>
<h3 id="1-递归切分_split_text"><a class="markdownIt-Anchor" href="#1-递归切分_split_text"></a> 1. 递归切分：<code>_split_text</code></h3>
<p>按「当前分隔符」把文本拆成若干段；若某段仍超过 <code>chunk_size</code>，则用「下一个更细的分隔符」对该段递归切分。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_split_text</span>(<span class="params">self, text: <span class="built_in">str</span>, separators: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># 无更多分隔符时，按字符兜底</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> separators:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._merge_splits(<span class="built_in">list</span>(text), <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    sep = separators[<span class="number">0</span>]                    <span class="comment"># 当前分隔符（如 "\n\n"）</span></span><br><span class="line">    rest_separators = separators[<span class="number">1</span>:]       <span class="comment"># 更细的分隔符（如 "\n", " ", ""）</span></span><br><span class="line">    splits = <span class="variable language_">self</span>._split_on_separator(text, sep)  <span class="comment"># 按 sep 切分</span></span><br><span class="line"></span><br><span class="line">    good_splits = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> splits:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._length_function(s) &lt;= <span class="variable language_">self</span>._chunk_size:</span><br><span class="line">            good_splits.append(s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> good_splits:</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> <span class="variable language_">self</span>._merge_splits(good_splits, sep)</span><br><span class="line">                good_splits = []</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> rest_separators:</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> <span class="variable language_">self</span>._merge_splits([s], sep)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> <span class="variable language_">self</span>._split_text(s, rest_separators)  <span class="comment"># 递归</span></span><br><span class="line">    <span class="keyword">if</span> good_splits:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> <span class="variable language_">self</span>._merge_splits(good_splits, sep)</span><br></pre></td></tr></tbody></table></figure>
<p>要点：</p>
<ul>
<li>用 <code>_split_on_separator(text, sep)</code> 得到当前层的 <code>splits</code>。</li>
<li>长度 ≤ <code>chunk_size</code> 的进入 <code>good_splits</code>，凑一批后 <code>_merge_splits</code> 合并并产出。</li>
<li>长度 &gt; <code>chunk_size</code> 的：若还有 <code>rest_separators</code> 则递归 <code>_split_text(s, rest_separators)</code>；否则按当前层合并或按字符兜底。</li>
</ul>
<h3 id="2-合并与重叠_merge_splits"><a class="markdownIt-Anchor" href="#2-合并与重叠_merge_splits"></a> 2. 合并与重叠：<code>_merge_splits</code></h3>
<p>将一批小片段合并成若干块，每块长度约 <code>chunk_size</code>，相邻块之间重叠 <code>chunk_overlap</code>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_merge_splits</span>(<span class="params">self, splits: <span class="type">List</span>[<span class="built_in">str</span>], separator: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    docs = []</span><br><span class="line">    current = []</span><br><span class="line">    total_len = <span class="number">0</span></span><br><span class="line">    sep_len = <span class="variable language_">self</span>._length_function(separator)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> splits:</span><br><span class="line">        n = <span class="variable language_">self</span>._length_function(s) + (sep_len <span class="keyword">if</span> current <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> total_len + n &gt; <span class="variable language_">self</span>._chunk_size <span class="keyword">and</span> current:</span><br><span class="line">            doc = <span class="variable language_">self</span>._join_docs(current, separator)</span><br><span class="line">            docs.append(doc)</span><br><span class="line">            <span class="comment"># 重叠：从队头丢弃片段，使剩余长度约等于 chunk_overlap</span></span><br><span class="line">            <span class="keyword">while</span> current <span class="keyword">and</span> (total_len &gt; <span class="variable language_">self</span>._chunk_overlap <span class="keyword">or</span> total_len + n &gt; <span class="variable language_">self</span>._chunk_size):</span><br><span class="line">                total_len -= <span class="variable language_">self</span>._length_function(current[<span class="number">0</span>]) + (sep_len <span class="keyword">if</span> <span class="built_in">len</span>(current) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">                current = current[<span class="number">1</span>:]</span><br><span class="line">            total_len = <span class="built_in">sum</span>(<span class="variable language_">self</span>._length_function(x) <span class="keyword">for</span> x <span class="keyword">in</span> current) + sep_len * (<span class="built_in">len</span>(current) - <span class="number">1</span>)</span><br><span class="line">        current.append(s)</span><br><span class="line">        total_len += n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> current:</span><br><span class="line">        docs.append(<span class="variable language_">self</span>._join_docs(current, separator))</span><br><span class="line">    <span class="keyword">return</span> docs</span><br></pre></td></tr></tbody></table></figure>
<p>要点：</p>
<ul>
<li>顺序遍历 <code>splits</code>，累加长度；超过 <code>chunk_size</code> 时先产出当前块，再根据 <code>chunk_overlap</code> 从队头丢弃片段，实现块间重叠。</li>
<li><code>_join_docs</code> 用 <code>separator</code> 把列表拼成最终字符串。</li>
</ul>
<h3 id="3-调用链"><a class="markdownIt-Anchor" href="#3-调用链"></a> 3. 调用链</h3>
<table>
<thead>
<tr>
<th>入口方法</th>
<th>内部调用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>split_text(text)</code></td>
<td><code>_split_text(text, self.separators)</code>，得到递归 + 合并后的块列表</td>
</tr>
<tr>
<td><code>split_documents(documents)</code></td>
<td>对每个 document 的 <code>page_content</code> 调 <code>split_text</code>，再按索引挂回 metadata</td>
</tr>
<tr>
<td><code>create_documents(texts, metadatas)</code></td>
<td>对每个 <code>text</code> 调 <code>split_text</code>，用 <code>metadatas</code> 构造 Document</td>
</tr>
</tbody>
</table>
<h2 id="常用方法"><a class="markdownIt-Anchor" href="#常用方法"></a> 常用方法</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>来源</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>split_text(text: str) -&gt; List[str]</code></td>
<td>对单个字符串切分，返回字符串列表</td>
<td><strong>继承 TextSplitter</strong>（本类重写内部逻辑，仍调 <code>_split_text</code>）</td>
</tr>
<tr>
<td><code>create_documents(texts: List[str], metadatas=None)</code></td>
<td>从字符串列表创建 Document 列表</td>
<td><strong>继承 TextSplitter</strong></td>
</tr>
<tr>
<td><code>split_documents(documents: List[Document]) -&gt; List[Document]</code></td>
<td>对 Document 列表切分，保留元数据</td>
<td><strong>继承 TextSplitter</strong></td>
</tr>
<tr>
<td><code>transform_documents(documents: List[Document]) -&gt; List[Document]</code></td>
<td>与 <code>split_documents</code> 等价，用于管道</td>
<td><strong>继承 TextSplitter</strong></td>
</tr>
<tr>
<td><code>from_tiktoken_encoder(...)</code></td>
<td>类方法，按 tiktoken 的 token 数切分</td>
<td>本类 / CharacterTextSplitter</td>
</tr>
<tr>
<td><code>from_huggingface_tokenizer(...)</code></td>
<td>类方法，按 HuggingFace tokenizer 切分</td>
<td>本类 / CharacterTextSplitter</td>
</tr>
<tr>
<td><code>from_language(language, ...)</code></td>
<td>类方法，按编程语言预设分隔符</td>
<td>本类 / CharacterTextSplitter</td>
</tr>
</tbody>
</table>
<p><strong>继承自 TextSplitter 的方法</strong>：<code>split_text</code>、<code>create_documents</code>、<code>split_documents</code>、<code>transform_documents</code>（基类定义接口与默认实现，本类通过重写 <code>_split_text</code> 等改变切分行为）。</p>
<h2 id="算法要点"><a class="markdownIt-Anchor" href="#算法要点"></a> 算法要点</h2>
<ol>
<li><strong>递归</strong>：用当前分隔符切分；若有片段长度仍大于 <code>chunk_size</code>，则用下一个分隔符对该片段递归切分。</li>
<li><strong>重叠</strong>：相邻块之间保留 <code>chunk_overlap</code> 个字符（或 token），避免语义在边界处断裂。</li>
<li><strong>长度计算</strong>：默认用 <code>len()</code>（字符数）；通过 <code>length_function</code> 可改为 token 数（如 tiktoken）。</li>
</ol>
]]></content>
      <categories>
        <category>agent</category>
        <category>源码解读</category>
        <category>textSplitter</category>
      </categories>
      <tags>
        <tag>agent</tag>
        <tag>python</tag>
        <tag>源码解读</tag>
      </tags>
  </entry>
</search>
